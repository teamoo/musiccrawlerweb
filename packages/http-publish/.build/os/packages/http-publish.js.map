{"version":3,"file":"\\packages\\http-publish.js","sources":["http-publish/http.publish.server.api.js"],"names":[],"mappings":";;;;;;;;AAAA,E;;AAEA,S;AACA,a;AACA,U;AACA,a;AACA,gB;;AAEA,E;;AAEA,qE;AACA,gF;AACA,gC;AACA,M;AACA,0B;AACA,sC;AACA,kB;;;AAGA,kB;;AAEA,sD;AACA,qC;;AAEA,+B;;AAEA,G;AACA,uC;AACA,W;AACA,wB;AACA,qD;AACA,G;AACA,8C;AACA,G;AACA,2E;AACA,wB;AACA,qC;AACA,qC;AACA,mC;AACA,6B;AACA,uB;AACA,uB;AACA,sB;AACA,E;;AAEA,iC;;AAEA,G;AACA,2C;AACA,W;AACA,6C;AACA,yB;AACA,G;AACA,+E;AACA,G;AACA,kF;AACA,8C;AACA,0C;AACA,wB;AACA,iC;AACA,E;;AAEA,G;AACA,oC;AACA,W;AACA,6C;AACA,wB;AACA,mG;AACA,sC;AACA,G;AACA,gF;AACA,G;AACA,4F;;AAEA,qD;AACA,qF;;AAEA,iC;AACA,yF;;AAEA,6E;AACA,0F;;AAEA,0C;AACA,4C;AACA,+E;AACA,iE;AACA,G;;AAEA,4B;AACA,6B;AACA,wE;AACA,G;;AAEA,+B;AACA,O;AACA,gD;AACA,gB;AACA,6B;AACA,yF;AACA,G;AACA,E;;AAEA,G;AACA,6B;AACA,W;AACA,+C;AACA,wC;AACA,wB;AACA,sC;AACA,G;AACA,qD;AACA,G;AACA,4E;AACA,yD;AACA,kC;AACA,gB;AACA,E;;AAEA,G;AACA,wC;AACA,W;AACA,yE;AACA,+C;AACA,wC;AACA,G;AACA,gE;AACA,G;AACA,8F;AACA,gD;AACA,2E;AACA,qF;AACA,Y;AACA,mF;AACA,K;AACA,U;AACA,2E;AACA,G;AACA,E;;AAEA,G;AACA,qC;AACA,W;AACA,2D;AACA,uB;AACA,G;AACA,wE;AACA,G;AACA,uE;AACA,sB;AACA,W;AACA,G;AACA,E;AACA,6B;AACA,mB;;AAEA,uD;AACA,mD;AACA,8B;AACA,G;;AAEA,wB;AACA,E;AACA,kE;AACA,yF;AACA,E;;AAEA,G;AACA,iC;AACA,W;AACA,2E;AACA,uB;AACA,G;AACA,2E;AACA,qE;AACA,G;AACA,2F;AACA,E;AACA,kD;AACA,0D;AACA,+D;AACA,U;AACA,+B;AACA,4B;AACA,sD;AACA,I;AACA,E;AACA,8B;AACA,Q;AACA,gE;AACA,G;AACA,E;AACA,E;;AAEA,G;AACA,8B;AACA,U;AACA,8B;AACA,uB;AACA,G;AACA,gC;AACA,M;AACA,sB;;AAEA,iC;AACA,kD;AACA,8C;AACA,4B;AACA,0C;AACA,K;;AAEA,K;AACA,I;AACA,G;AACA,gE;AACA,qD;AACA,E;;AAEA,G;AACA,uB;AACA,U;AACA,0B;AACA,4I;AACA,yH;AACA,+H;AACA,gH;AACA,6G;AACA,2H;AACA,4G;AACA,kH;AACA,0F;AACA,uB;AACA,kE;AACA,G;AACA,8E;AACA,8E;AACA,4E;AACA,8E;AACA,8C;AACA,G;AACA,a;AACA,G;AACA,gB;AACA,G;AACA,kD;AACA,G;AACA,sE;AACA,G;AACA,yD;AACA,G;AACA,iE;AACA,G;AACA,4C;AACA,G;AACA,G;AACA,2D;AACA,sB;AACA,e;AACA,qB;AACA,wB;AACA,wB;AACA,yB;AACA,sB;AACA,sB;AACA,wB;AACA,oB;AACA,E;AACA,sC;AACA,E;AACA,mC;AACA,qG;;AAEA,6B;AACA,iC;AACA,yE;AACA,G;AACA,E;AACA,4C;;AAEA,2C;AACA,mB;;AAEA,4C;;AAEA,oB;AACA,qB;;AAEA,6C;AACA,qC;AACA,wC;AACA,gD;AACA,4D;AACA,+B;AACA,2D;;AAEA,8B;AACA,mC;AACA,qC;AACA,oC;AACA,0B;AACA,sE;AACA,c;AACA,2B;AACA,iD;AACA,O;AACA,M;AACA,G;;AAEA,mB;AACA,qD;AACA,iC;AACA,2C;AACA,sF;AACA,2D;AACA,2C;AACA,8B;AACA,a;AACA,mD;AACA,kD;AACA,4B;AACA,mF;AACA,sB;AACA,0C;AACA,6E;AACA,S;AACA,Q;AACA,K;;AAEA,yD;AACA,gC;AACA,I;AACA,6C;AACA,+E;AACA,0E;AACA,mD;AACA,0B;AACA,c;AACA,O;AACA,4D;AACA,uB;AACA,gB;AACA,G;AACA,iE;AACA,6B;;AAEA,oD;AACA,gE;;AAEA,mC;AACA,+D;;AAEA,sD;AACA,qB;;AAEA,4D;AACA,wC;AACA,0B;AACA,kD;AACA,6B;AACA,e;AACA,a;AACA,a;;AAEA,gD;AACA,uB;AACA,0E;AACA,kB;AACA,wD;AACA,8D;AACA,yD;AACA,yB;AACA,6B;AACA,8E;AACA,oB;AACA,0B;AACA,4G;AACA,a;AACA,W;;AAEA,gB;AACA,2F;AACA,S;AACA,Q;AACA,K;;AAEA,8B;AACA,mD;AACA,0B;AACA,c;AACA,O;AACA,4D;AACA,uB;AACA,gB;AACA,G;AACA,iE;AACA,6B;;AAEA,wF;AACA,gC;AACA,e;AACA,qD;AACA,sE;AACA,8B;AACA,oF;AACA,wB;AACA,4C;AACA,+E;AACA,W;;AAEA,gB;AACA,2F;AACA,e;AACA,Q;AACA,K;;AAEA,iC;AACA,sD;AACA,2B;AACA,c;AACA,O;AACA,4D;AACA,uB;AACA,gB;AACA,G;AACA,iE;AACA,6B;;AAEA,wF;AACA,gC;AACA,e;AACA,qD;AACA,gE;AACA,8B;AACA,oF;AACA,wB;AACA,4C;AACA,+E;AACA,W;;AAEA,gB;AACA,2F;AACA,c;AACA,Q;AACA,K;;AAEA,G;;AAEA,wB;AACA,wB;AACA,E;AACA,mD;AACA,8F;AACA,E;AACA,gB;;AAEA,G;AACA,yB;AACA,U;AACA,2E;AACA,uB;AACA,G;AACA,2E;AACA,qE;AACA,G;AACA,wC","sourcesContent":["/*\n\nGET /note\nGET /note/:id\nPOST /note\nPUT /note/:id\nDELETE /note/:id\n\n*/\n\n// Could be cool if we could serve some api doc or even an api script\n// user could do <script href=\"/note/api?token=1&user=2\"></script> and be served\n// a client-side javascript api?\n// Eg.\n// HTTP.api.note.create();\n// HTTP.api.login(username, password);\n// HTTP.api.logout\n\n\n_publishHTTP = {};\n\n// Cache the names of all http methods we've published\n_publishHTTP.currentlyPublished = [];\n\nvar defaultAPIPrefix = '/api/';\n\n/**\n * @method _publishHTTP.getPublishScope\n * @private\n * @param {Object} scope\n * @returns {httpPublishGetPublishScope.publishScope}\n * \n * Creates a nice scope for the publish method\n */\n_publishHTTP.getPublishScope = function httpPublishGetPublishScope(scope) {\n  var publishScope = {};\n  publishScope.userId = scope.userId;\n  publishScope.params = scope.params;\n  publishScope.query = scope.query;\n  // TODO: Additional scoping\n  // publishScope.added\n  // publishScope.ready\n  return publishScope;\n};\n\n_publishHTTP.formatHandlers = {};\n\n/**\n * @method _publishHTTP.formatHandlers.json\n * @private\n * @param {Object} result - The result object\n * @returns {String} JSON\n * \n * Formats the output into JSON and sets the appropriate content type on `this`\n */\n_publishHTTP.formatHandlers.json = function httpPublishJSONFormatHandler(result) {\n  // Set the method scope content type to json\n  this.setContentType('application/json');\n  // Return EJSON string\n  return EJSON.stringify(result);\n};\n\n/**\n * @method _publishHTTP.formatResult\n * @private\n * @param {Object} result - The result object\n * @param {Object} scope\n * @param {String} [defaultFormat='json'] - Default format to use if format is not in query string.\n * @returns {Any} The formatted result\n * \n * Formats the result into the format selected by querystring eg. \"&format=json\"\n */\n_publishHTTP.formatResult = function httpPublishFormatResult(result, scope, defaultFormat) {\n\n  // Get the format in lower case and default to json\n  var format = scope && scope.query && scope.query.format || defaultFormat || 'json';\n\n  // Set the format handler found\n  var formatHandlerFound = !!(typeof _publishHTTP.formatHandlers[format] === 'function');\n\n  // Set the format handler and fallback to default json if handler not found\n  var formatHandler = _publishHTTP.formatHandlers[(formatHandlerFound) ? format : 'json'];\n\n  // Check if format handler is a function\n  if (typeof formatHandler !== 'function') {\n    // We break things the user could have overwritten the default json handler\n    throw new Error('The default json format handler not found');\n  }\n\n  if (!formatHandlerFound) {\n    scope.setStatusCode(500);\n    return '{\"error\":\"Format handler for: `' + format + '` not found\"}';\n  }\n\n  // Execute the format handler\n  try {\n    return formatHandler.apply(scope, [result]);\n  } catch(err) {\n    scope.setStatusCode(500);\n    return '{\"error\":\"Format handler for: `' + format + '` Error: ' + err.message + '\"}';\n  }\n};\n\n/**\n * @method _publishHTTP.error\n * @private\n * @param {String} statusCode - The status code\n * @param {String} message - The message\n * @param {Object} scope\n * @returns {Any} The formatted result\n * \n * Responds with error message in the expected format\n */\n_publishHTTP.error = function httpPublishError(statusCode, message, scope) {\n  var result = _publishHTTP.formatResult(message, scope);\n  scope.setStatusCode(statusCode);\n  return result;\n};\n\n/**\n * @method _publishHTTP.getMethodHandler\n * @private\n * @param {Meteor.Collection} collection - The Meteor.Collection instance\n * @param {String} methodName - The method name\n * @returns {Function} The server method\n * \n * Returns the DDP connection handler, already setup and secured\n */\n_publishHTTP.getMethodHandler = function httpPublishGetMethodHandler(collection, methodName) {\n  if (collection instanceof Meteor.Collection) {\n    if (collection._connection && collection._connection.method_handlers) {\n      return collection._connection.method_handlers[collection._prefix + methodName];\n    } else {\n      throw new Error('HTTP publish does not work with current version of Meteor');\n    }\n  } else {\n    throw new Error('_publishHTTP.getMethodHandler expected a collection');\n  }\n};\n\n/**\n * @method _publishHTTP.unpublishList\n * @private\n * @param {Array} names - List of method names to unpublish\n * @returns {undefined}\n * \n * Unpublishes all HTTP methods that have names matching the given list.\n */\n_publishHTTP.unpublishList = function httpPublishUnpublishList(names) {\n  if (!names.length) {\n    return;\n  }\n  \n  // Carry object for methods\n  var methods = {};\n\n  // Unpublish the rest points by setting them to false\n  for (var i = 0, ln = names.length; i < ln; i++) {\n    methods[names[i]] = false;\n  }\n\n  HTTP.methods(methods);\n  \n  // Remove the names from our list of currently published methods\n  _publishHTTP.currentlyPublished = _.difference(_publishHTTP.currentlyPublished, names);\n};\n\n/**\n * @method _publishHTTP.unpublish\n * @private\n * @param {String|Meteor.Collection} [name] - The method name or collection\n * @returns {undefined}\n * \n * Unpublishes all HTTP methods that were published with the given name or \n * for the given collection. Call with no arguments to unpublish all.\n */\n_publishHTTP.unpublish = function httpPublishUnpublish(/* name or collection, options */) {\n  \n  // Determine what method name we're unpublishing\n  var name = (arguments[0] instanceof Meteor.Collection) ?\n          defaultAPIPrefix + arguments[0]._name : arguments[0];\n          \n  // Unpublish name and name/id\n  if (name && name.length) {\n    _publishHTTP.unpublishList([name, name + '/:id']);\n  } \n  \n  // If no args, unpublish all\n  else {\n    _publishHTTP.unpublishList(_publishHTTP.currentlyPublished);\n  }\n  \n};\n\n/**\n * @method HTTP.publishFormats\n * @public\n * @param {Object} newHandlers\n * @returns {undefined}\n * \n * Add publish formats. Example:\n ```js\n HTTP.publishFormats({\n\n    json: function(inputObject) {\n      // Set the method scope content type to json\n      this.setContentType('application/json');\n      // Return EJSON string\n      return EJSON.stringify(inputObject);\n    }\n\n  });\n ```\n */\nHTTP.publishFormats = function httpPublishFormats(newHandlers) {\n  _.extend(_publishHTTP.formatHandlers, newHandlers);\n};\n\n/**\n * @method HTTP.publish\n * @public\n * @param {Object} options\n * @param {String} [name] - Restpoint name (url prefix). Optional if `collection` is passed. Will mount on `/api/collectionName` by default.\n * @param {Meteor.Collection} [collection] - Meteor.Collection instance. Required for all restpoints except collectionGet\n * @param {String} [options.defaultFormat='json'] - Format to use for responses when `format` is not found in the query string.\n * @param {String} [options.collectionGet=true] - Add GET restpoint for collection? Requires a publish function.\n * @param {String} [options.collectionPost=true] - Add POST restpoint for adding documents to the collection?\n * @param {String} [options.documentGet=true] - Add GET restpoint for documents in collection? Requires a publish function.\n * @param {String} [options.documentPut=true] - Add PUT restpoint for updating a document in the collection?\n * @param {String} [options.documentDelete=true] - Add DELETE restpoint for deleting a document in the collection?\n * @param {Function} [publishFunc] - A publish function. Required to mount GET restpoints.\n * @returns {undefined}\n * @todo this should use options argument instead of optional args\n * \n * Publishes one or more restpoints, mounted on \"name\" (\"/api/collectionName/\"\n * by default). The GET restpoints are subscribed to the document set (cursor)\n * returned by the publish function you supply. The other restpoints forward\n * requests to Meteor's built-in DDP methods (insert, update, remove), meaning\n * that full allow/deny security is automatic.\n * \n * __Usage:__\n * \n * Publish only:\n * \n * HTTP.publish({name: 'mypublish'}, publishFunc);\n * \n * Publish and mount crud rest point for collection /api/myCollection:\n * \n * HTTP.publish({collection: myCollection}, publishFunc);\n * \n * Mount CUD rest point for collection and documents without GET:\n * \n * HTTP.publish({collection: myCollection});\n * \n */\nHTTP.publish = function httpPublish(options, publishFunc) {\n  options = _.extend({\n    name: null,\n    collection: null,\n    defaultFormat: null,\n    collectionGet: true,\n    collectionPost: true,\n    documentGet: true,\n    documentPut: true,\n    documentDelete: true\n  }, options || {});\n  \n  var collection = options.collection;\n  \n  // Use provided name or build one\n  var name = (typeof options.name === \"string\") ? options.name : defaultAPIPrefix + collection._name;\n\n  // Make sure we have a name\n  if (typeof name !== \"string\") {\n    throw new Error('HTTP.publish expected a collection or name option');\n  }\n  \n  var defaultFormat = options.defaultFormat;\n\n  // Rig the methods for the CRUD interface\n  var methods = {};\n\n  // console.log('HTTP restpoint: ' + name);\n\n  // list and create\n  methods[name] = {};\n\n  if (options.collectionGet && publishFunc) {\n    // Return the published documents\n    methods[name].get = function(data) {\n      // Format the scope for the publish method\n      var publishScope = _publishHTTP.getPublishScope(this);\n      // Get the publish cursor\n      var cursor = publishFunc.apply(publishScope, [data]);\n\n      // Check if its a cursor\n      if (cursor && cursor.fetch) {\n        // Fetch the data fron cursor\n        var result = cursor.fetch();\n        // Return the data\n        return _publishHTTP.formatResult(result, this, defaultFormat);\n      } else {\n        // We didnt get any\n        return _publishHTTP.error(200, [], this);\n      }\n    };\n  }\n\n  if (collection) {\n    // If we have a collection then add insert method\n    if (options.collectionPost) {\n      methods[name].post = function(data) {\n        var insertMethodHandler = _publishHTTP.getMethodHandler(collection, 'insert');\n        // Make sure that _id isset else create a Meteor id\n        data._id = data._id || Random.id();\n        // Create the document\n        try {\n          // We should be passed a document in data\n          insertMethodHandler.apply(this, [data]);\n          // Return the data\n          return _publishHTTP.formatResult({ _id: data._id }, this, defaultFormat);\n        } catch(err) {\n          // This would be a Meteor.error?\n          return _publishHTTP.error(err.error, { error: err.message }, this);\n        }\n      };\n    }\n\n    // We also add the findOne, update and remove methods\n    methods[name + '/:id'] = {};\n    \n    if (options.documentGet && publishFunc) {\n      // We have to have a publish method inorder to publish id? The user could\n      // just write a publish all if needed - better to make this explicit\n      methods[name + '/:id'].get = function(data) {\n        // Get the mongoId\n\t\tvar mongoId;\n\t\ttry {\n\t\t\tmongoId = new Meteor.Collection.ObjectID(this.params.id);\n\t\t} catch (exception) {\n\t\t\tmongoId = '';\n\t\t}\n        // We would allways expect a string but it could be empty\n        if (mongoId !== '') {\n\n          // Format the scope for the publish method\n          var publishScope = _publishHTTP.getPublishScope(this);\n\n          // Get the publish cursor\n          var cursor = publishFunc.apply(publishScope, [data]);\n\n          // Result will contain the document if found\n          var result;\n\n          // Check to see if document is in published cursor\n          cursor.forEach(function(doc) {\n            if (!result) {\n              if (EJSON.equals(doc._id,mongoId)) {\n                result = doc;\n              }\n            }\n          });\n\n          // If the document is found the return\n          if (result) {\n            return _publishHTTP.formatResult(result, this, defaultFormat);\n          } else {\n            // We do a check to see if the doc id exists\n            var exists = collection.findOne({ _id: mongoId });\n            // If it exists its not published to the user\n            if (exists) {\n              // Unauthorized\n              return _publishHTTP.error(401, { error: 'Unauthorized' }, this);\n            } else {\n              // Not found\n              return _publishHTTP.error(404, { error: 'Document with id ' + mongoId + ' not found' }, this);\n            }\n          }\n\n        } else {\n          return _publishHTTP.error(400, { error: 'Method expected a document id' }, this);\n        }\n      };\n    }\n\n    if (options.documentPut) {\n      methods[name + '/:id'].put = function(data) {\n        // Get the mongoId\n\t\tvar mongoId;\n\t\ttry {\n\t\t\tmongoId = new Meteor.Collection.ObjectID(this.params.id);\n\t\t} catch (exception) {\n\t\t\tmongoId = '';\n\t\t}\n        // We would allways expect a string but it could be empty\n        if (mongoId !== '') {\n\n          var updateMethodHandler = _publishHTTP.getMethodHandler(collection, 'update');\n          // Create the document\n          try {\n            // We should be passed a document in data\n            updateMethodHandler.apply(this, [{ _id: mongoId }, data]);\n            // Return the data\n            return _publishHTTP.formatResult({ _id: mongoId }, this, defaultFormat);\n          } catch(err) {\n            // This would be a Meteor.error?\n            return _publishHTTP.error(err.error, { error: err.message }, this);\n          }\n\n        } else {\n          return _publishHTTP.error(400, { error: 'Method expected a document id' }, this);\n        }      \n      };\n    }\n\n    if (options.documentDelete) {\n      methods[name + '/:id'].delete = function(data) {\n         // Get the mongoId\n\t\tvar mongoId;\n\t\ttry {\n\t\t\tmongoId = new Meteor.Collection.ObjectID(this.params.id);\n\t\t} catch (exception) {\n\t\t\tmongoId = '';\n\t\t}\n        // We would allways expect a string but it could be empty\n        if (mongoId !== '') {\n\n          var removeMethodHandler = _publishHTTP.getMethodHandler(collection, 'remove');\n          // Create the document\n          try {\n            // We should be passed a document in data\n            removeMethodHandler.apply(this, [{ _id: mongoId }]);\n            // Return the data\n            return _publishHTTP.formatResult({ _id: mongoId }, this, defaultFormat);\n          } catch(err) {\n            // This would be a Meteor.error?\n            return _publishHTTP.error(err.error, { error: err.message }, this);\n          }\n\n        } else {\n          return _publishHTTP.error(400, { error: 'Method expected a document id' }, this);\n        }     \n      };\n    }\n\n  }\n\n  // Publish the methods\n  HTTP.methods(methods);\n  \n  // Mark these method names as currently published\n  _publishHTTP.currentlyPublished = _.union(_publishHTTP.currentlyPublished, _.keys(methods));\n  \n}; // EO Publish\n\n/**\n * @method HTTP.unpublish\n * @public\n * @param {String|Meteor.Collection} [name] - The method name or collection\n * @returns {undefined}\n * \n * Unpublishes all HTTP methods that were published with the given name or \n * for the given collection. Call with no arguments to unpublish all.\n */\nHTTP.unpublish = _publishHTTP.unpublish;"]}